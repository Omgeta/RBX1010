{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to RBX2030","text":"<p>This website hosts notes, exercises and other written guides for learning Roblox Game Development using the Lua Programming Language. You can explore the links on the left, or search for keywords in the search bar above.</p>"},{"location":"#useful-resources","title":"Useful Resources","text":"<ul> <li>Lua Guide</li> <li>Luau Guide</li> <li>Roblox Documentation</li> </ul>"},{"location":"notes/1.%20Lua/1/","title":"1. Overview","text":"<p>Learning Objectives</p> <ul> <li>understand the prerequisites</li> <li>understand how the key concepts of game development are interrelated</li> </ul>"},{"location":"notes/1.%20Lua/1/#what-is-this-website-about","title":"What is this website about?","text":"<p>RBX2030 is designed for programmers who are able to solve simple algorithmic problems with common constructs like loops, conditions, and functions. While introductory courses such as NUS's CS1010 satisfy this requirement, students tend to write only short single-file programs alone before moving on to the next problem and never going back to their old code.</p> <p>Game development consists of large, complicated codebases maintained by many different developers who may not even communicate but nonetheless have their code used by others. We need to develop skills of writing code in a maintainable and organised way while still maintaining speed and correctness.</p> <p>Quote</p> <p>\"Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. Code for readability.\"</p> <p>John Woods.</p>"},{"location":"notes/1.%20Lua/1/#what-is-this-website-not-about","title":"What is this website not about?","text":"<p>RBX2030 is not about Lua programming. We will not comprehensively cover Lua syntax and features, except those relevant and useful for game development. In fact, we will avoid and even ban usage of using certain Lua features (such as <code>eval</code>) for safety purposes even though they may be useful elsewhere.</p> <p>Similarly, this website is not about software development. Software engineering is a broad discipline on its own and deserves another module. Still, we will go over many concepts such as OOP, Networking, Databases and Security, which may be useful for software develoment. But we will not comprehensively cover any specific topic.</p> <p>Finally, this RBX2030 does not focus on efficiency. Efficiency is important and is expected in all the code written. However, there are too many different optimization problems in game development to cover within a single website. In striving for maintainability, we may even have to sacrifice some computation efficiency when performance is relatively unimportant.</p> <p>Quote</p> <p>\"Fancy algorithms are slow when n is small, and n is usually small. Fancy algorithms have big constants. Until you know that n is frequently going to be big, don't get fancy.\"</p> <p>Rob Pike.</p>"},{"location":"notes/1.%20Lua/1/#why-roblox","title":"Why Roblox?","text":"<p>Roblox is a game development platform which lets us write code in a relatively simple language (Lua) with relatively simple libraries and tooling (Roblox Standard Library and Studio) to write very real game experiences. It is very beginner friendly and there is not a big learning curve before we are able to produce fun experiences.</p> <p>While Roblox is definitely not as performant or Unity or Unreal, with good code, we can still write performant code. Most issues with Roblox games stem from bad code rather than the bad engine, and we can still use many tricks to overcome the flaws of few flaws of the engine.</p>"},{"location":"notes/1.%20Lua/1/#why-lua","title":"Why Lua?","text":"<p>Lua, meaning \"moon\" in Portuguese, is a lightweight, high-level, interpreted scripting language created in 1993 in Brazil. Lua was initially developed to provide flexibility in applications, particularly for configuration and extension. Its small footprint and portability have made it popular in game development, where it is often embedded as a scripting engine.</p> <p>While the Roblox Engine is built primarily in C++, the Lua scripting interface allows us to call performant engine code and ultimately create performant game experiences through a relatively simple programming language.</p>"},{"location":"notes/1.%20Lua/2/","title":"2. Variables and Types","text":"<p>Learning Objectives</p> <ul> <li>be familiar with Lua variables and primitive types</li> <li>contrast between statically typed language vs. dynamically typed language</li> <li>be aware of the limitations of the dynamically typed languages</li> </ul>"},{"location":"notes/1.%20Lua/2/#primitive-types","title":"Primitive Types","text":"<p>Lua has a small but powerful set of primitive types which can be used to describe data:</p> <ul> <li><code>nil</code>: Represents the absence of a value.</li> <li><code>boolean</code>: Can be true or false.</li> <li><code>number</code>: Lua uses double-precision floating-point numbers.</li> <li><code>string</code>: Immutable sequences of characters.</li> <li><code>table</code>: Associative arrays that can represent arrays, dictionaries, or objects.</li> <li><code>function</code>: First-class functions for procedural programming.</li> <li><code>thread</code>: Represents independent threads of execution (used for coroutines).</li> <li><code>userdata</code>: Used to store arbitrary C data.</li> </ul> <p>We can use the <code>type()</code> function to check the datatype of a value or a variable to return a string representation of the data type.</p> <pre><code>print(type(1))      -- number\nprint(type(\"1\"))    -- string\nprint(type(type))   -- function\n</code></pre> <p>Since functions are first-class citizens in Lua, we can pass functions to other functions. This means we can also pass functions as callbacks to other functions, letting us form powerful higher-order functions.</p> <p>Common mistake</p> <p>While <code>type()</code> works for Lua primitives, it returns <code>\"userdata\"</code> for all Roblox data types. When dealing with Roblox data types, we must use the <code>typeof()</code> function instead. <pre><code>print(type(Instance.new(\"Part\")))   -- userdata\nprint(typeof(Instance.new(\"Part\"))) -- Instance\n</code></pre></p>"},{"location":"notes/1.%20Lua/2/#variables","title":"Variables","text":"<p>Variables are an abstraction to hold values which we can use to manipulate and pass around values. We can create variables simply by associating a variable name with its value. By default, all variables are global but we can make them local variables using the <code>local</code> keyword:</p> <pre><code>a = 2        -- global variable holding 2\nlocal b = 2  -- local variable holding 2\n</code></pre> <p>Local variables follow standard block-scoping rules and are always faster to access and modify than global variables. For the rest of this course, we will exclusively use local variables.</p>"},{"location":"notes/1.%20Lua/2/#dynamic-vs-static-typing","title":"Dynamic vs. Static Typing","text":"<p>Lua is a dynamically typed language which means that the same variable can hold values of different unrelated types. Note that, the type is associated with the values, and the type of the variable changes depending on the value it holds.</p> <p>For example, we can do the following in Lua:</p> <pre><code>local x = 4  -- x is a number\nx = \"5\"      -- ok, x is now a string\n</code></pre> <p>but we can't do the same in a statically typed language, such as Java or C:</p> <pre><code>int x;  // declare x is variable of type int\nx = 4;  // ok, because x is still of type int\nx = \"5\" // error, cannot assign a string to an int\n</code></pre> <p>This means that we don't have the same notion of compile time type and runtime type as in other languages like Java.</p>"},{"location":"notes/1.%20Lua/2/#runtime-type-checking","title":"Runtime Type Checking","text":"<p>Notice that, due to Lua being dynamically typed, types can only be resolved at runtime and type checks too can only be done at runtime. While this provides flexibility, it can lead to potential issues in complex systems like games.</p> <p>In game development, bugs caused by type mismatches can be especially problematic because games often involve long, interactive sessions with unpredictable player behavior. For example, consider the function <code>mathPow(base, exp)</code> which expects numbers. If we accidentally pass in a invalid value like a table:</p> <pre><code>local base = 3\n...\nbase = {} -- accidental\n...\nmathPow(base, 2) -- throws error only when the line is run\n</code></pre> <p>Lua won't detect this mistake when the code is written or loaded. Instead, the error will occur only when the code runs at that specific point. In a game, this might be a rare condition triggered only under specific gameplay circumstances. For example:</p> <ul> <li>Suppose this code is part of a damage calculation function for a boss enemy in a specific level.</li> <li>The player might not encounter this boss until hours into the game.</li> <li>When they do, the game could crash or throw a runtime error, disrupting the player\u2019s experience.</li> </ul>"},{"location":"notes/1.%20Lua/2/#possible-solution-input-validation","title":"Possible Solution: Input Validation","text":"<p>One way to partially deal with this problem would be do use input validation. We could always check the types explicitly before performing operations:</p> <pre><code>if type(base) == \"number\" and type(exp) == \"number\" then\n    -- do something\nend\n</code></pre> <p>However, this is inelegant and we would also still not be solving the issue of being able to know at the type of writing code whether there are any type errors.</p>"},{"location":"notes/1.%20Lua/2/#ideal-solution-type-annotation","title":"Ideal Solution: Type Annotation","text":"<p>Luau, the Lua variant used by Roblox adds static type checking through type annotations. We will cover Luau features in-depth in a later section but for now, here is an example of how Luau works:</p> <pre><code>--!strict\nlocal base: number = 3\nbase = {} -- Error: Type '{}' cannot be converted to 'number'\n</code></pre>"},{"location":"notes/1.%20Lua/3/","title":"3. Booleans and Conditionals","text":"<p>Learning Objectives</p> <ul> <li>be familiar with basic boolean logic in Lua</li> <li>understand how to use conditional if-then-else statements</li> <li>be familiar with common idioms for control flow</li> </ul>"},{"location":"notes/1.%20Lua/3/#booleans","title":"Booleans","text":"<p>Booleans are simple: there are only two values, <code>true</code> and <code>false</code>. These are the building blocks for logic and flow control.</p> <p>Lua provides basic comparison operators to compare values and return a boolean result:</p> <ul> <li><code>==</code> (equals to)</li> <li><code>~=</code> (not equals to)</li> <li><code>&gt;</code> (more than) and <code>&gt;=</code> (more than or equal to)</li> <li><code>&lt;</code> (less than) and <code>&lt;=</code> (less than or equal to)</li> </ul> <pre><code>local a = 2\nlocal b = 3\nprint(a ~= b)    -- output: true\n</code></pre> <p>Lua also provides the three basic logical operators: <code>and</code>, <code>or</code>, and <code>not</code> to allow developers to chain together conditions to form more complex conditions. These operators behave exactly the same as in other languages.</p> <pre><code>print(true and false)   -- output: false\nprint(true or false)    -- output: true\nprint(not true)         -- output: false\n</code></pre>"},{"location":"notes/1.%20Lua/3/#if-then-statements","title":"<code>if-then</code> statements","text":"<p>Lua <code>if-then</code> statements are used to control the flow of execution based on a condition, similarly to in other programming languages.</p> <pre><code>if condition then\n    -- code to execute if condition is true\nend\n</code></pre> <p>We can also add <code>elseif</code> and <code>else</code> blocks for when other conditions are true or when no conditions are true respectively.</p> <pre><code>if condition1 then\n    -- code if condition1 is true\nelseif condition2 then\n    -- code if condition2 is true\nelse\n    -- code if neither condition is true\nend\n</code></pre> <p>Truthy and Falsy</p> <p><code>false</code> and <code>nil</code> are considered falsy values and are coerced into false when used in conditions. Likewise, <code>true</code> and all other values (including 0 and \"\") are truthy and are coerced into true. This means that any value can be used as a condition since they all are coerced into booleans. However, incorrect usage may lead to logical errors sometimes. <pre><code>local winner = nil\n...                 -- some code to find a possible winner\nif winner then      -- instead of \"if winner ~= nil then\"\n    print(\"Winner is\" .. winner)\nend\n</code></pre> If unsure, just be explicit and write out the full condition.</p> <p>One-Liner <code>if-then</code></p> <p>Lua lets us write one-liner <code>if-then</code> statements which lets us write terser code. For instance, we might use this in a function to return early if parameters passed are incorrect. <pre><code>function divide(num, denom)\n    if denom == 0 then return end\n\nend\n</code></pre></p>"},{"location":"notes/1.%20Lua/3/#default-values","title":"Default values","text":"<p>Sometimes, it's useful to assign default values in case a variable is nil or doesn't meet a condition. This can be done in Lua using a common idiom:</p> <pre><code>local result = value or default\nlocal character = player.Character or player:WaitForCharacter()\n</code></pre>"},{"location":"notes/1.%20Lua/3/#ternary-statements","title":"Ternary statements","text":"<p>Ternary statements can also be written in Lua using another idiom:</p> <pre><code>local sign = x &lt; 0 and \"negative\" or \"positive\"\n</code></pre>"},{"location":"notes/1.%20Lua/4/","title":"4. Tables and Loops","text":"<p>Learning Objectives</p> <ul> <li>be familiar with Lua tables</li> <li>understand the uses of metatables and metamethods</li> <li>understand how to use <code>while</code> and <code>for</code> loops</li> </ul>"},{"location":"notes/1.%20Lua/4/#tables-as-associative-arrays","title":"Tables as Associative Arrays","text":"<p>Tables in Lua are neither values nor variables but objects. The table type implements associative arrays, which are arrays that can be indexed by any value except <code>nil</code>.</p> <p>Tables do not have a fixed size and can be changed dynamically. We use tables to represent ordinary arrays, dictionaries, sets, queues and other data structures. All tables are created with the <code>{}</code> constructor expression. Values are accessed and assigned with the <code>[]</code> operator.</p> <pre><code>-- creating a table of 3 elements indexed by 1,2\nlocal a = {}\na[1] = \"apples\"\na[2] = \"bananas\"\n\n-- accessing the 2nd element\nprint(a[2]) -- output: \"bananas\"\n</code></pre> <p>Common mistake</p> <p>Unlike in other languages, accessing unset indexes returns <code>nil</code> instead of throwing errors <pre><code>local a = {}\nprint(a[1000])  -- output: \"nil\"\n</code></pre></p>"},{"location":"notes/1.%20Lua/4/#arrays","title":"Arrays","text":"<p>Tables can be used as arrays simply by adding in values into the constructor. Note that tables in Lua are by default 1-indexed.</p> <pre><code>-- using constructors to create and initialize arrays in a single expression\nlocal squares = {1, 4, 9, 16, 25, 36, 49, 64, 81}\n</code></pre> <p>Changing index</p> <p>We can also start an array at index 0, 1, or any other value by just manually setting indexes:</p> <pre><code>-- starts at -5 and increments by 1 each index\nlocal squares = {[-5] = 1, 4, 9, 16, 25, 36, 49, 64, 81}\n</code></pre> <p>However, we recommend always starting arrays with index 1 to allow the Lua standard library functions to work properly.</p>"},{"location":"notes/1.%20Lua/4/#dictionaries","title":"Dictionaries","text":"<p>Tables can also be used as dictionaries, allowing you to associate keys with values. These keys can be strings, numbers, or any other type except <code>nil</code></p> <pre><code>-- using constructors to create and initialize dictionaries in a single expression\nlocal shoppingList = {\n    [\"apples\"] = 3,\n    [\"oranges\"] = 4\n}\n</code></pre> <p>If the keys are valid Lua identifiers (i.e. strings that are alphanumeric without spaces or special characters), we can omit the <code>[]</code> during table creation:</p> <pre><code>local shoppingListTwo = {\n    apples = 3,\n    oranges = 4\n}\n</code></pre>"},{"location":"notes/1.%20Lua/4/#dot-syntax","title":"Dot Syntax","text":"<p>Dictionaries with Lua identifier keys can be also be quickly indexed by the dot syntax as shorthand for accessing or modifying the table.</p> <pre><code>-- creating a table with string keys\nlocal person = {name = \"Alice\", age = 25}\nprint(person.name)  -- output: \"Alice\"\nperson.age = 26     -- modifying person[\"age\"]\n</code></pre>"},{"location":"notes/1.%20Lua/4/#metatables","title":"Metatables","text":"<p>Tables in Lua can have a special feature called metatables, which allow you to define custom behaviors for operations performed on the table. Metatables enable powerful features like operator overloading, handling undefined keys, and more.</p>"},{"location":"notes/1.%20Lua/4/#setting-a-metatable","title":"Setting a metatable","text":"<p>You can assign a metatable to a table using the <code>setmetatable</code> library function:</p> <pre><code>local t = {}\nlocal mt = {}\nsetmetatable(t, mt)\n</code></pre>"},{"location":"notes/1.%20Lua/4/#metamethods","title":"Metamethods","text":"<p>Metatables can define metamethods - special fields that control the behaviour of a table. These are similar to dunder methods in Python. Common metamethods include:</p> <ul> <li><code>__index</code> (define what happens when accessing a nonexistent key)</li> <li><code>__newindex</code> (define what happens when assigning to a nonexistent key)</li> <li><code>__add</code>, <code>__sub</code>, <code>__mul</code>, etc. (define how operators behave with the table)</li> </ul> <p>For instance, here we use <code>__index</code> to provide a default value:</p> <pre><code>local point = {}\nlocal defaults = {x = 0, y = 0}\nlocal mt = {__index = defaults}\nsetmetatable(point, mt)\n\nprint(point.x, point.y) -- output: \"0 0\"\npoint.x = 10\nprint(point.x, point.y) -- output: \"10 0\"\n</code></pre> <p>We will later cover how to use metatables and metamethods to simulate classes and OOP-like behaviour in Lua.</p>"},{"location":"notes/1.%20Lua/4/#for-loops","title":"<code>for</code> loops","text":"<p><code>for</code> loops are used to iterate over a finite sequence of numbers or values.</p>"},{"location":"notes/1.%20Lua/4/#numeric-for-loop","title":"Numeric <code>for</code> loop","text":"<p>Numeric <code>for</code> loop is used to iterate over a sequence of numbers, and it includes a start value, stop value, and optional step value (the increment per iteration)</p> <pre><code>for variable = start, stop, step do\n    -- loop body\nend\n</code></pre> <p>Numerically iterating over arrays</p> <p>We can use the numeric <code>for</code> loop to iterate over arrays, similar to how it would be done in other programming languages like so: <pre><code>for i in 1, #t do   -- #t returns the size of table t\n    local v = t[i]  -- getting value at index i\n    -- loop body\nend\n</code></pre></p>"},{"location":"notes/1.%20Lua/4/#ipairs","title":"<code>ipairs</code>","text":"<p><code>ipairs</code> is a standard library function which helps to iterate over a table until the first <code>nil</code> is found. We typically use it to traverse continuous arrays. It is the idiomatic way to traverse arrays in Lua.</p> <pre><code>-- iterate over every element in the array\nfor index, value in ipairs(t) do\n    -- loop body\nend\n</code></pre>"},{"location":"notes/1.%20Lua/4/#ipairs_1","title":"<code>ipairs</code>","text":"<p><code>pairs</code> is a standard library function which helps to iterate over all key-value pairs in a table. We typically use it to traverse dictionaries.</p> <pre><code>-- iterate over every key-value pair in the dictionary\nfor key, value in pairs(t) do\n    -- loop body\nend\n</code></pre> <p>Generic <code>for</code> loops</p> <p>Luau also has generic <code>for</code> loop syntactic sugar which automatically determines which standard library function, <code>ipairs</code> or <code>pairs</code>, to use when dealing with a table. It is the idiomatic way to traverse tables in Roblox. <pre><code>for x, value in t do -- x might be a key or index depending on the type of table\n    -- loop body\nend\n</code></pre></p>"},{"location":"notes/1.%20Lua/4/#while-loops","title":"<code>while</code> loops","text":"<p><code>while</code> loops are used when you want to repeat execution of the loop body for as long as the condition stays true.</p> <pre><code>while condition do\n    -- loop  body\nend\n</code></pre>"},{"location":"notes/1.%20Lua/4/#repeat-until-loops","title":"<code>repeat-until</code> loops","text":"<p><code>repeat-until</code> loop is similar to a standard <code>while</code> loop except that that the loop body is guaranteed to be executed at least once, and repeated until the condition is reached</p> <pre><code>repeat\n    -- loop body\nuntil condition\n</code></pre>"},{"location":"notes/1.%20Lua/5/","title":"5. Functions","text":"<p>Learning Objectives</p> <ul> <li>be familiar with Lua functions</li> <li>understand how to use functions as a tool for abstraction and deduplication</li> <li>understand the uses of higher order functions</li> <li>know when to use closures to represent stateful functions</li> </ul>"},{"location":"notes/1.%20Lua/5/#functions","title":"Functions","text":"<p>Functions in Lua are the main tool for forming abstractions. We define functions similarly to other programming languages.</p> <pre><code>-- function foo which takes two parameters and returns their sum\nfunction foo(x, y)\n    return x + y\nend\n</code></pre> <p>Functions are really useful as abstractions over complex processes. By writing good functions with clear documentation, we allow other programmers to use our function without needing to understand the internals of the implementation.</p> <p>Functions also allow us to consolidate repeated code into a single unit which can be modified once and have its changed replicated for every instance where its called.</p> <p>Note that, unlike some other languages, Lua does not support function overloading.</p> <p>Common mistake</p> <p>Lua does not throw any errors when we pass less or more arguments than necessary. Suppose we have the previous function <code>foo(x, y)</code> then we have this mapping from arguments to parameters: <pre><code>CALL             PARAMETERS\nf(3)             x=3, y=nil\nf(3, 4)          x=3, y=4\nf(3, 4, 5)       x=3, y=4   (5 is discarded)\n</code></pre> This can lead to runtime errors if not careful.</p> <p>Default arguments</p> <p>We can use the Lua's nonstrict argument checking to provide default arguments to functions. <pre><code>function foo(a, b)\n    a = a or 1  -- default value for a is 1\n    b = b or -1 -- default value for b is -1\n    return a + b\nend\n</code></pre></p> <p>Multiple results</p> <p>Functions can also return multiple results which can be stored in a multi-assignment statement. <pre><code>function bar(a, b)\n    return a+1, b+1\nend\nlocal c, d = bar(1, 2)  -- c will be 2, d will be 3\n</code></pre> Similarly to variable arguments, excess variables will have the value <code>nil</code></p> <p>Since functions are considered first-class citizens in Lua, we can do a lot of interesting things with them.</p>"},{"location":"notes/1.%20Lua/5/#callbacks","title":"Callbacks","text":"<p>Callbacks are functions passed as arguments to another function which we call a higher order function.</p> <p>For instance, we can have the higher-order function <code>compute</code> which takes in numbers <code>x, y</code> and a binary function we call <code>operation</code> and returns <code>operation(x, y)</code> whatever the operation may be:</p> <pre><code>-- higher order function\nfunction compute(x, y, operation)\n    return operation(x, y)\nend\n\n-- callbacks\nlocal add = function(a, b) return a + b end\nlocal mult = function(a, b) return a * b end\n\n-- call compute with different callbacks\nprint(compute(5, 10, add))      -- output: 15\nprint(compute(5, 10, mult))     -- output: 50\n</code></pre> <p>We can use this pattern to design many more flexible and powerful functions.</p>"},{"location":"notes/1.%20Lua/5/#anonymous-functions","title":"Anonymous functions","text":"<p>Functions can also be anonymous, meaning that they do not have to be declared with a name. A very common usecase for anonymous functions is to pass them to higher-order functions as callbacks without having to name them.</p> <pre><code>-- we pass in an anonymous subtraction function as a callback\nprint(compute(5, 10, function (a, b) return a - b end))     -- output: -5\n</code></pre> <p>Naming anonymous functions</p> <p>While less common, we can also name anonymous functions by assigning them to a variable. We usually do this when we are returning a function.</p> <pre><code>-- naming an anonymous function\nlocal add = function(a, b) return a + b end\n-- naming any function returned by another function\nlocal randomFn = createRandomFunction()\n</code></pre>"},{"location":"notes/1.%20Lua/5/#closures","title":"Closures","text":"<p>Lua support closures, which are functions which capture and \"remember\" the environment in which they were created. Closures are particularly useful for representing stateful functions such as a counter.</p> <pre><code>function createCounter(start)\n    local count = start or 0    -- let 0 be the default counter start value\n    return function()           -- return a function with count variable captured\n        count = count + 1\n        return count\n    end\nend\n\nlocal counter = createCounter(20)   -- create a counter starting at 20\nprint(counter())                    -- output: 21, the state has changed\nprint(counter())                    -- output: 22, the state has changed again\n</code></pre>"},{"location":"notes/1.%20Lua/5/#local-functions","title":"Local functions","text":"<p>Interestingly, functions can also be local which means that they follow the same scoping rules as local variables.</p> <p>For instance, if we declare a local function inside of a function, the local function is not accessible from outside.</p> <pre><code>function outer()\n    local function inner() end\n\n    inner()     -- works\nend\n\ninner()         -- doesn't work\n</code></pre> <p>This is of course useful to prevent inner functions like helper functions from polluting the namespace.</p>"},{"location":"notes/1.%20Lua/6/","title":"6. Type Annotations","text":""},{"location":"notes/2.%20OOP/1/","title":"1. Abstraction and Encapsulation","text":"<p>Learning Objectives</p> <ul> <li>know the definitions of abstraction and encapsulation</li> <li>understand the concept of information hiding to enforce the abstraction barrier</li> <li>understand the drawback of breaking the abstraction barrier</li> <li>be familiar with using ModuleScripts for abstraction and encapsulation</li> </ul>"},{"location":"notes/2.%20OOP/1/#abstraction","title":"Abstraction","text":"<p>Abstraction is the idea that we can separate the concerns between the implementer and user (or client) of the code by hiding implementation details from the users.</p> <p>Take for instance the abstraction being played by your browser: a user can just throw in a URL in the searchbar and go along their merry way to their favourite website without having to worry about how it's actually achieved (i.e. HTTP requests, DNS requests, networking protocols, etc).</p> <p>Similarly, when we work with code in large projects, it's generally a good idea to break code into different \"modules\" if you will, where the client calling the code does not need to know how the module works, just how to use it. We already do this all the time when we call functions like <code>print()</code>. Most of us know nothing about how these functions work but - here's the important thing - we don't need to; we just need to know how to call the code that we trust.</p>"},{"location":"notes/2.%20OOP/1/#information-hiding","title":"Information Hiding","text":"<p>Information hiding is the principle that we must restrict access to a \"module\"'s internal implementation. In other words, there must be an abstraction barrier between the implementation and the client.</p> <p>We call the invisible barrier between the client and implementer the abstraction barrier: something that helps us separate our concerns. The implementer can write their module code without having to worry about the client randomly calling a function they aren't supposed to and breaking everything. Isn't that a great thing not to have to worry about?</p> <p>On the other hand, if we break the abstraction barrier then we might inadvertently allow the client to mess with code in unintended ways. Implementing this abstraction barrier properly is similar to minimizing the attack surface of our code; we can reduce logic errors by only letting our code being accessed in a certain way.</p>"},{"location":"notes/2.%20OOP/1/#encapsulation","title":"Encapsulation","text":"<p>Encapsulation is a different but related idea which says that we should bundle together data with the associated functions (also called methods) which act on it on the same side of the abstraction barrier.</p>"},{"location":"notes/2.%20OOP/1/#modulescripts","title":"ModuleScripts","text":"<p>ModuleScripts in Roblox are a type of script used to organize and reuse code. They are excellent tools for implementing abstraction and encapsulation in your projects. Unlike regular scripts, ModuleScripts return a table that acts as their public interface, which allows you to define functions, variables, or constants that can be accessed from other scripts while keeping internal logic hidden. After writing a ModuleScript, we can use the <code>require()</code> function to load it from an external script, i.e. the client.</p>"},{"location":"notes/2.%20OOP/1/#local-scope-and-public-interface","title":"Local Scope and Public Interface","text":"<p>Within a ModuleScript, you can define local variables and functions that are only accessible within the script itself. These act as private members, supporting the principle of information hiding. The table returned by the ModuleScript defines its public interface, listing the functions or variables that other scripts can access.</p> <p>For example:</p> <pre><code>-- UtilityModule.lua\nlocal UtilityModule = {}\n\n-- Private function (local)\nlocal function sayHello(name)\n    print(\"Hello, \" .. name .. \"!\")\nend\n\n-- Public function (attached to table)\nfunction UtilityModule.sayHelloTimes10(name)\n    for i = 1, 10 do\n        sayHello(name)\n    end\nend\n\nreturn UtilityModule\n</code></pre> <p>Here, <code>sayHelloTimes10</code> is a public function which can be used by the requiring script but <code>sayHello</code> is private because it is local to the ModuleScript. See how through this abstraction barrier, we force the client, the requiring script, to only be able to print out the string in multiples of 10, because they have no way of accessing the private local functions.</p>"},{"location":"notes/2.%20OOP/1/#singletons","title":"Singletons","text":"<p>When we introduce state into the equation through private local variables, we create something called a Singleton,which has the same shared state across all requires. That is, it is a kind of global abstraction over state.</p> <p>For instance:</p> <pre><code>-- GameManager.lua\nlocal GameManager = {}\n\n-- Private member (local)\nlocal score = 0\n\n-- Public functions (attached to table)\nfunction GameManager.addScore(points)\n    score += points\nend\n\nfunction GameManager.getScore()\n    return score\nend\n\nreturn GameManager\n</code></pre> <p>Here, <code>addScore</code> and <code>getScore</code> are part of the public interface, while <code>score</code> remains hidden within the module and cannot be directly accessed by classes which <code>require</code> this module. If a script with this module adds to the score, other scripts which also have this module will see the change in the score. This is a very useful behaviour in certain cases in game development, such as for global game state managers or when we know there will only ever be a single instance.</p> <p>So far, we don't have a way to initialise unique instances which each store their own state. In the next unit, we will cover how to use ModuleScripts to implement classes, which are able to represent more powerful types of abstractions.</p>"},{"location":"notes/2.%20OOP/2/","title":"2. Classes and Objects","text":"<p>Learning Objectives</p> <ul> <li>be familiar with how to create and use classes</li> <li>understand the difference between classes and objects</li> <li>see the relationship between classes and OOP</li> </ul>"},{"location":"notes/2.%20OOP/2/#classes","title":"Classes","text":"<p>Classes can be seen as blueprints for creating objects which are different instances of the same class. Classes allow us to define the common characteristics and behaviours of a group of related objects.</p> <p>Take for instance, the wrapper classes like <code>String</code> in Java or <code>std::string</code> in C++, we have the stored data (the text string) and a bunch of methods which act on that data (e.g. <code>length()</code> returns the length of that string data). This is an abstraction and encapsulation like we've seen before, except that we can have different instances instead of being confined to a Singleton.</p> <p>For instance:</p> <pre><code>-- CarClass.lua\nlocal Car = {}\nCar.__index = Car\n\nfunction Car.new(color, speed)\n    local self = setmetatable({}, Car)\n    self.color = color\n    self.speed = speed\n    return self\nend\n\nfunction Car:Drive()\n    print(\"The \" .. self.color .. \" car is driving at \" .. self.speed .. \" mph.\")\nend\n\nreturn Car\n</code></pre> <p>Here, <code>Car.new</code> is the constructor that initializes a new object of class <code>Car</code> and returns it, and <code>Car:Drive</code> is a method available to all instances of the <code>Car</code> class.</p>"},{"location":"notes/2.%20OOP/2/#objects","title":"Objects","text":"<p>Objects are the concrete realization of a class. While a class defines the general structure and behaviour, an object represents a specific instance created from that class, with its own unique data.</p> <p>For instance, we can create <code>Car</code> objects like this:</p> <pre><code>local Car = require(game.ServerScriptService.CarClass)\n\nlocal redCar = Car.new(\"red\", 60)\nlocal blueCar = Car.new(\"blue\", 80)\n\nredCar:Drive() -- Outputs: \"The red car is driving at 60 mph.\"\nblueCar:Drive() -- Outputs: \"The blue car is driving at 80 mph.\"\n</code></pre>"},{"location":"notes/2.%20OOP/2/#object-oriented-programming","title":"Object-Oriented Programming","text":"<p>Object-oriented programming (OOP) is the programming paradigm based upon the concepts of objects in order to model our programming problems.</p> <p>One way to look at OOP is as a mirror of our natural world, to break everything down into objects which have certain properties, exhibit certain behaviours, and allow certain actions.</p>"},{"location":"notes/2.%20OOP/3/","title":"3. Inheritance","text":"<p>Learning objectives</p> <ul> <li>understand inheritance as a mechanism to extend existing code</li> <li>know how to extend superclasses in Lua</li> <li>understand inheritance as a subtype</li> </ul>"},{"location":"notes/2.%20OOP/4/","title":"4. Composition","text":"<p>Learning objectives</p> <ul> <li>how to compose a new class from existing classes using Composition</li> <li>know when to use composition over inheritance</li> </ul>"},{"location":"notes/2.%20OOP/5/","title":"5. Polymorphism","text":"<p>Learning objectives</p> <ul> <li>understand the definition of polymorphism</li> <li>know how to use polymorphims to simply code</li> </ul>"},{"location":"notes/2.%20OOP/6/","title":"6. Class Type Annotations","text":""},{"location":"practices/1/","title":"1. Stack","text":"<p>Prerequisite</p> <ul> <li>Familiar with classes in Lua</li> <li>Setup code editor with Lua</li> </ul>"},{"location":"practices/1/#overview","title":"Overview","text":"<p>A Stack is a very common data structure used in programming which stores values in last in, first out order (LIFO). Implement a stack as a class in Lua to store arbitrary values of any type.</p> <p>Recall that classes can be created like:</p> <pre><code>local Box = {}\nBox.__index = Box\n\nfunction Box.new(x) -- static constructor\n  local self = setmetatable({}, Box)\n  self.x = x\n  return self\nend\n\nfunction Box:Get() -- instance method (note ':')\n  return self.x\nend\n\nreturn Box\n</code></pre>"},{"location":"practices/1/#tasks","title":"Tasks","text":""},{"location":"practices/1/#task-1-stack-class","title":"Task 1: <code>Stack</code> class","text":"<p>Create a skeleton <code>Stack</code> class with the constructor and necessary fields. Add a <code>toString</code> method so that the string representation as shown in the examples below could be returned.</p> <p>For instance:</p> <pre><code>local stack = Stack.new(3)  -- stack with max size 3\nprint(stack:toString())     -- should print \"[]\"\n</code></pre>"},{"location":"practices/1/#task-2-push-and-pop","title":"Task 2: <code>Push()</code> and <code>Pop()</code>","text":"<p>Add <code>Push()</code> and <code>Pop()</code> methods to manipulate the stack. <code>Push(x)</code> should push the value of <code>x</code> onto the top of the stack. <code>Pop()</code> should pop the top value off the stack and return it. Also modify the <code>toString()</code> method to correctly display the values in the stack.</p> <p>For instance:</p> <pre><code>local stack = Stack.new(3)\nstack:Push(1)\nstack:Push(2)\nprint(stack:toString())     -- should print \"[1 2]\"\nlocal popped = stack:Pop()\nprint(popped)               -- should print \"2\"\nprint(stack:toString())     -- should print \"[1]\"\n</code></pre>"},{"location":"practices/1/#task-3-isfull-and-isempty","title":"Task 3: <code>IsFull()</code> and <code>IsEmpty()</code>","text":"<p>Add <code>IsFull()</code> and <code>IsEmpty()</code> methods which check if the stack is full or empty</p> <p>For instance:</p> <pre><code>local stack = Stack.new(1)\nstack:Push(1)\nprint(stack.IsFull())   -- should print \"true\"\nprint(stack.IsEmpty())  -- should print \"false\"\n</code></pre>"},{"location":"practices/1/#task-4-bounds-checking","title":"Task 4: Bounds checking","text":"<p>Use the <code>IsFull()</code> and <code>IsEmpty()</code> methods in your code to make sure that <code>Push()</code> and <code>Pop()</code> do not add/remove values innappropriately.</p> <p>For instance:</p> <pre><code>local stack = Stack.new(1)\nstack:Pop()     -- should print \"error: stack empty\"\nstack:Push(1)\nstack:Push(2)   -- should print \"error: stack full\"\n</code></pre>"},{"location":"practices/1/#solution","title":"Solution","text":"LuaJava <pre><code>local Stack = {}\nStack.__index = Stack\n\nfunction Stack.new(size: number)\n    local self = setmetatable({}, Stack)\n    self.size = size\n    return self\nend\n\nfunction Stack:push(value)\n    if self:isFull() then\n        print(\"Stack is full. Cannot push any values.\")\n        return\n    end\n    table.insert(self.array, value)\nend\n\nfunction Stack:pop()\n    if self:isEmpty() then\n        print(\"Stack is empty. Cannot pop any values.\")\n        return nil\n    end\n    return table.remove(self.array)\nend\n\nfunction Stack:peek()\n    if #self.array == 0 then\n        print(\"Stack is empty. Cannot peek any values.\")\n        return nil\n    end\n    return self.array[#self.array]\nend\n\nfunction Stack:isFull()\n    return #self.array == self.size\nend\n\nfunction Stack:isEmpty()\n    return #self.array == 0\nend\n\nreturn Stack\n</code></pre> <pre><code>public class Stack {\n  private int head;\n  private Integer[] array;\n  private int size;\n\n  public Stack(int size) {\n    this.size = size;\n    this.head = 0;\n    this.array = new Integer[this.size];\n  }\n\n  public void push(int x) {\n    if (isFull()) {\n      System.out.println(\"Stack is full. Cannot push any values.\");\n    } else {\n      this.array[this.head++] = x;\n    }\n  }\n\n  public Integer pop() {\n    if (isEmpty()) {\n      System.out.println(\"Stack is empty. Cannot pop any values.\");\n      return null;\n    } else {\n      return this.array[--this.head];\n    }\n  }\n\n  public Integer peek() {\n    // or just pop push if lazy\n    if (isEmpty()) {\n      System.out.println(\"Stack is empty. Cannot peek any values.\");\n      return null;\n    } else {\n      Integer res = this.array[--this.head];\n      this.head++;\n      return res;\n    }\n  }\n\n  public boolean isFull() {\n    return this.size == this.head;\n  }\n\n  public boolean isEmpty() {\n    return this.head == 0;\n  }\n}\n</code></pre>"},{"location":"practices/1/#extra","title":"Extra","text":"<p>Consider what else we can do with stacks? What if we wanted stacks to be of dynamic size? Could be implement stacks more simply just by using tables? How can we use stacks in game development?</p>"},{"location":"practices/2/","title":"2. List","text":"<p>Prerequisite</p> <ul> <li>Familiar with classes in Lua</li> <li>Setup code editor with Lua</li> </ul>"},{"location":"practices/2/#overview","title":"Overview","text":"<p>A List is a very common data structure that stores values in nodes, where each node contains a value and a pointer to the next node. Unlike arrays (not tables), linked lists can dynamically grow or shrink and do not require contiguous memory. Implement a linked list as a class in Lua to store arbitrary values of any type.</p> <p>Recall that classes can be created like:</p> <pre><code>local Box = {}\nBox.__index = Box\n\nfunction Box.new(x) -- static constructor\n  local self = setmetatable({}, Box)\n  self.x = x\n  return self\nend\n\nfunction Box:Get() -- instance method (note ':')\n  return self.x\nend\n\nreturn Box\n</code></pre>"},{"location":"practices/2/#tasks","title":"Tasks","text":""},{"location":"practices/2/#task-1-list-class","title":"Task 1: <code>List</code> class","text":"<p>Create a skeleton <code>List</code> class with the constructor and necessary fields. Add a <code>toString</code> method so that the string representation as shown in the examples below could be returned.</p> <p>For instance:</p> <pre><code>local list = List.new(1)  -- create a single List node\nprint(list:toString())   -- should print \"[1]\"\n</code></pre>"},{"location":"practices/2/#task-2-append-and-pop","title":"Task 2: <code>Append()</code> and <code>Pop()</code>","text":"<p>Add <code>Append()</code> and <code>Pop()</code> methods to manipulate the list. <code>Append(x)</code> should append <code>x</code> in a <code>List</code> to the back. <code>Pop()</code> should pop the last value in the list and return it. Also modify the <code>toString()</code> method to correctly display the values in the list.</p> <p>For instance:</p> <pre><code>local list = List.new(1)\nlist:Append(2)\nprint(list:toString())     -- should print \"[1 2]\"\nlocal popped = list:Pop()\nprint(popped)               -- should print \"2\"\nprint(list:toString())     -- should print \"[1]\"\n</code></pre>"},{"location":"practices/2/#task-3-length","title":"Task 3: <code>Length()</code>","text":"<p>Add a <code>Length()</code> method to get the length of the instance list.</p> <p>For instance:</p> <pre><code>local list = List.new(1)\nlist:Append(2)\nlist:Append(3)\nprint(list:Length())      -- should print \"3\"\n</code></pre>"},{"location":"practices/2/#task-4-geti-and-removei","title":"Task 4: <code>Get(i)</code> and <code>Remove(i)</code>","text":"<p>Add a <code>Get(i)</code> method to retrieve the List at index <code>i</code> (1-based). The method should traverse and return the <code>List</code> node if it exists, or <code>nil</code> if the index is out of bounds. Add a <code>Remove(i)</code> method to remove only the <code>List</code> at index <code>i</code> and return it.</p> <p>Hint: consider using two traversal variables</p> <p>For instance:</p> <pre><code>local list = List.new(1)\nlist:Append(2)\nlist:Append(3)\nprint(list:Get(2):toString())       -- should print \"[2 3]\"\nprint(list:Remove(2):toString())    -- should print \"[2]\"\nprint(list:toString())              -- should print \"[1 3]\"\n</code></pre>"},{"location":"practices/2/#solution","title":"Solution","text":"LuaJava <pre><code>local List = {}\nList.__index = List\n\n-- Constructor: Initialize a node with data and a nil tail\nfunction List.new(data)\n    local self = setmetatable({}, List)\n    self.data = data\n    self.tail = nil\n    return self\nend\n\n-- Add an element with value `x` to the end of the list\nfunction List:append(x)\n    local curr = self\n    while curr.tail do\n        curr = curr.tail\n    end\n    curr.tail = List.new(x)\nend\n\n-- Pop the last List and return its value\nfunction List:pop()\n    if not self.tail then\n        return self.data\n    end\n\n    local curr = self\n    while curr.tail and curr.tail.tail do\n        curr = curr.tail\n    end\n    local value = curr.tail.data\n    curr.tail = nil\n    return value\nend\n\n-- Get the List at index `i`\nfunction List:get(i: number)\n    local curr = self\n    local j = 1\n\n    while j &lt; i and curr.tail do\n        curr = curr.tail\n        j = j + 1\n    end\n\n    return j == i and curr or nil\nend\n\n-- Remove the List at index `i`\nfunction List:remove(i: number)\n    local prev = nil\n    local curr = self\n    local j = 1\n\n    while j &lt; i and curr.tail do\n        prev = curr\n        curr = curr.tail\n        j = j + 1\n    end\n\n    if j == i then\n        -- for non-head, we stitch the prev to the next tail\n        -- for head removal edge case (undefined by qn),\n        -- i choose to cut off the remaining list and let GC clean it up\n        if prev then\n            prev.tail = curr.tail\n        end\n        curr.tail = nil\n        return curr\n    end\n    return nil\nend\n\n-- Get the length of the list\nfunction List:length()\n    local curr = self.tail\n    local i = 1\n    while curr do\n        i = i + 1\n        curr = curr.tail\n    end\n    return i\nend\n\nreturn List\n</code></pre> <pre><code>// This implementation is closer to the CS1101S implementation\npublic class List {\n  private int data;\n  private List tail;\n\n  // Constructor\n  public List(int data) {\n    this.data = data;\n    this.tail = null;\n  }\n\n  // Add an element with value x to the end\n  public void append(int x) {\n    List curr = this;\n    while (curr.tail != null) {\n      curr = curr.tail;\n    }\n    curr.tail = new List(x);\n  }\n\n  // Pop the last node and return the value\n  public int pop() {\n    if (this.tail == null) {\n      return this.data;\n    }\n\n    List curr = this;\n    while (curr.tail != null &amp;&amp; curr.tail.tail != null) {\n      curr = curr.tail; \n    }\n    int res = curr.tail.data;\n    curr.tail = null;\n    return res;\n  }\n\n  // Get the List at index i\n  public List get(int i) {\n    List curr = this;\n    int j = 0;\n\n    while (j &lt; i &amp;&amp; curr.tail != null) {\n        curr = curr.tail;\n        j++;\n    }\n\n    if (j == i) {\n        return curr;\n    }\n    return null;\n  }\n\n  // Remove the List at index i\n  public List remove(int i) {\n    List prev = null;\n    List curr = this;\n    int j = 0;\n\n    while (j &lt; i &amp;&amp; curr.tail != null) {\n      prev = curr;\n      curr = curr.tail;\n      j++;\n    }\n\n    if (j == i) {\n      // for non-head, we stitch the prev to the next tail\n      // for head removal edge case (undefined by qn),\n      // i choose to cut off the remaining list and let GC clean it up\n      if (prev != null) {\n        prev.tail = curr.tail;\n      }\n      curr.tail = null;\n      return curr;\n    }\n    return null;\n  }\n\n  // Get the length of the list\n  public int length() {\n    int i = 1;\n    // you can use for loops like this too, but rest of the code\n    // uses while loops for clarity\n    for (List curr = this.tail; curr != null; curr = curr.tail, i++);\n    return i;\n  }\n\n  // Helper function\n  public void print() {\n    List curr = this;\n    while (curr != null) {\n      System.out.print(curr.data + \" \");\n      curr = curr.tail;\n    }\n    System.out.print(\"\\n\");\n  }\n}\n</code></pre>"},{"location":"practices/2/#extra","title":"Extra","text":"<p>Consider what else we can do with lists? Is there a point of implementing lists when we already have tables? How could you use tables to write a much terser linked list? How could we use lists in game development?</p>"},{"location":"practices/3/","title":"3. SettingsButton","text":"<p>Prerequisite</p> <ul> <li>Installed Roblox Studio</li> <li>Familiar with OOP in Lua</li> <li>Familiar with the Client-Server model</li> <li>Familiar with Roblox script containers</li> </ul>"},{"location":"practices/3/#overview","title":"Overview","text":"<p>We want to create a simple Settings menu with different pages but Roblox only has some basic GUI classes to work with. We will use OOP to design reusable UI components for our settings menu. Firstly, we will focus on designing a single SettingsButton class which contains a description of a setting and a display of the current option.</p> <p></p>"},{"location":"practices/3/#tasks","title":"Tasks","text":""},{"location":"practices/3/#task-1-setting-up-screengui-and-frame","title":"Task 1: Setting up <code>ScreenGui</code> and <code>Frame</code>","text":"<p>Before we can start displaying any GuiObject on the screen, we need to set up a container for all GuiObjects we want to render for the player.</p> <p>Unlike the custom pseudoclasses we have written in Lua so far, Roblox Engine Classes which are all subclasses of Instance must be constructed with the <code>Instance.new(className)</code> constructor.</p> <p>For example, here we create a Part, make it transparent and add it to the workspace:</p> <pre><code>local part = Instance.new(\"Part\")   -- ref to an unrendered part (parent = nil)\npart.Transparency = 0.5\npart.Parent = game.Workspace        -- set parent last as an optimization to not render early\n</code></pre> <p>In the case of GUIs, <code>GuiObjects</code> only render if they are somewhere under a <code>ScreenGui</code> object which is placed in the players <code>PlayerGui</code> folder. Typically, we will also have a <code>Frame</code> under the <code>ScreenGui</code> which is a container for related <code>GuiObjects</code>.</p> <p>Write a LocalScript under either the ReplicatedFirst or StarterGui folders which creates the necessary hierarchy of <code>ScreenGui</code> and <code>Frame</code> such that new <code>GuiObjects</code> such as <code>TextLabel</code> can be rendered.</p> <p>Recall that we can get a reference to the players <code>PlayerGui</code> folder like so:</p> <pre><code>local playerGui = game.Players.LocalPlayer.PlayerGui\nlocal playerGui = script.Parent     -- only works if the script is in the StarterGui folder\n</code></pre> <p>Remember to also adjust the <code>Frame</code> fields so that it takes up the whole screen (or however much of the screen as you want) for us to test our future <code>SettingsButton</code>.</p>"},{"location":"practices/3/#task-2-settingsbutton-constructor","title":"Task 2: <code>SettingsButton</code> constructor","text":"<p>Now we are finally ready to create our <code>SettingsButton</code> class. Note that in the image example, we have two types of settings buttons: one that changes between several options (e.g. View Distance changing between Low, Medium High) and another that runs some function (e.g. Save Progress saving to the database). For simplicity sake, we will only write the latter for now.</p> <p>We should use composition in this implementation with these suggested fields:</p> <ul> <li><code>self.label</code> (<code>TextLabel</code> containing the setting name)</li> <li><code>self.icon</code> (<code>ImageLabel</code> containing the setting icon)</li> <li><code>self.button</code> (<code>ImageButton</code> which is the parent of <code>label</code> and <code>icon</code>)</li> <li><code>self.callback</code> (<code>function</code> that we want to call on button press)</li> </ul> <p>We should be able to create a <code>SettingsButton</code> like so:</p> <pre><code>local frame = ... --- parent frame\nlocal saveData = function() print(\"Saving...\") end\nlocal saveIcon = \"rbxassetid://12967618029\"\nlocal settingsButton = SettingsButton.new(\"Save Progress\", saveIcon, saveData, frame)\n</code></pre>"},{"location":"practices/3/#task-3-connecting-callbacks","title":"Task 3: Connecting callbacks","text":"<p>Roblox follows event-based programming which means that most, if not all <code>Instance</code> come with events which we can attach callback functions to. For our case, we want to attach our callback to the <code>Activated</code> event on <code>ImageButton</code>.</p> <p>For example, this <code>Part</code> calls a function when touched (i.e. the <code>Touched</code> event is fired).</p> <pre><code>local part = game.Workspace.Part1   -- some arbitrary part\nlocal function hello()\n    print(\"Hello world!\")\nend\npart.Touched:Connect(hello)\n</code></pre>"},{"location":"practices/3/#task-4-destroy-cleanup","title":"Task 4: <code>Destroy()</code> cleanup","text":"<p>We should also implement a <code>Destroy()</code> method to delete all instances and disconnect all events.</p> <p>For example, this is how we destroy a <code>Box</code> containing many <code>Part</code>s</p> <pre><code>...\nfunction Box.new()\n    local self = setmetatable({}, Box)\n    self.partOne = Instance.new(\"Part\")\n    self.partTwo = Instance.new(\"Part\")\n    return self\nend\n\nfunction Box:Destroy()\n    self.partOne:Destroy()\n    self.partTwo:Destroy()\n    setmetatable(self, nil) -- break linkage to metatable\nend\n...\n</code></pre> <p>If we create connections, we may also want to explictly disconnect them.</p>"},{"location":"practices/3/#solution","title":"Solution","text":"StarterPlayerScripts/Client.luauReplicatedStorage/SettingsButton.luau <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal SettingsButton = require(ReplicatedStorage.Modules.SettingsButton)\nlocal player = game.Players.LocalPlayer\n\n-- Create GUI and Frame containers\nlocal gui = Instance.new(\"ScreenGui\")\ngui.Parent = player:WaitForChild(\"PlayerGui\")\nlocal frame = Instance.new(\"Frame\")\nframe.Size = UDim2.new(1, 0, 1, 0)\nframe.Transparency = 1\nframe.Parent = gui\n\n-- Create SettingsButton instance\nlocal saveData = function()\n    print(\"Saving...\")\nend\nlocal saveIcon = \"rbxassetid://12345678\"\nlocal settingsButton = SettingsButton.new(\"Save Progress\", saveIcon, saveData, frame)\n</code></pre> <pre><code>local SettingsButton = {}\n\nSettingsButton.__index = SettingsButton\n\nfunction SettingsButton.new(text: string, image: string, callback: () -&gt; (), parent: Instance)\nlocal self = setmetatable({}, SettingsButton)\n\n    self.callback = callback\n\n    local imageButton = Instance.new(\"ImageButton\") :: ImageButton\n    imageButton.Size = UDim2.new(0.4, 0, 0.2, 0)\n    imageButton.AnchorPoint = Vector2.new(0.5, 0.5)\n    imageButton.Position = UDim2.new(0.5, 0, 0.5, 0)\n    imageButton.BackgroundColor3 = Color3.fromRGB(200, 200, 200)\n    imageButton.Activated:Connect(callback)\n    self.button = imageButton\n\n    local imageLabel: ImageLabel = Instance.new(\"ImageLabel\")\n    imageLabel.Image = image\n    imageLabel.Parent = imageButton\n    imageLabel.Size = UDim2.new(0, 20, 0, 20)\n    imageLabel.AnchorPoint = Vector2.new(0, 0.5)\n    imageLabel.Position = UDim2.new(0.8, 0, 0.5, 0)\n    self.icon = imageLabel\n\n    local textLabel: TextLabel = Instance.new(\"TextLabel\")\n    textLabel.Text = text\n    textLabel.Parent = imageButton\n    textLabel.AnchorPoint = Vector2.new(0, 0.5)\n    textLabel.Position = UDim2.new(0.2, 0, 0.5, 0)\n    self.label = textLabel\n\n    self.button.Parent = parent\n\n    return self\nend\n\nfunction SettingsButton:Destroy()\n    self.label:Destroy()\n    self.icon:Destroy()\n    self.button:Destroy()\n    setmetatable(self, nil)\nend\n\nreturn SettingsButton\n</code></pre> <p>This is not an ideal solution in the real world, but it suffices to show the application of classes for UI components.</p>"},{"location":"practices/3/#extra","title":"Extra","text":"<p>Why not try adding a header to the settings page using a <code>TextLabel</code>, or a <code>ScrollingFrame</code> under the main container so that we can have a long list of <code>SettingsButton</code>. Why not add more event connections like an onHover effect to make it more responsive? There are many different objects and constraints available to allow you to style and customize the UI. Read the API and experiment.</p> <p>Notice that for this example, we don't actually need any methods since we can use only the single constructor. Wouldn't it be wiser to just write this as a function as part of a <code>SettingsButton</code> module? Notice that classes only become really useful when we have to manage state as well as organise our code.</p> <p>In an actual game, we might have many different types of settings options such as sliders and dropdown menus. In that case, we would write a general \"abstract\" class/local function which is used by concrete subclasses/ exported functions which we use in our menus. Try writing such an implementation.</p>"}]}